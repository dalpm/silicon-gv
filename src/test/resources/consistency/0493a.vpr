// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

field val: Int

predicate one(a: Ref) {
  acc(a.val)
}

predicate two(a: Ref, i: Int) {
  acc(a.val) //&& a.val == i
}

define access_val(as) forall a: Ref :: { a.val } a in as ==> acc(a.val)
define access_one(as) forall a: Ref :: { one(a) } a in as ==> one(a)
define access_two(as, is) forall a: Ref, i: Int :: { two(a, i) } a in as && i in  is ==> two(a, i)

function foo_val(as: Set[Ref]): Int
    requires access_val(as)

function foo_one(as: Set[Ref]): Int
    requires access_one(as)

function foo_two(as: Set[Ref], is: Set[Int]): Int
    requires access_two(as, is)

method test_val(as: Set[Ref]) {
    inhale access_val(as)
    inhale foo_val(as) == 0
    exhale foo_val(as) == 0
}

method test_val_2(as: Set[Ref], bs: Set[Ref]) {
    inhale access_val(as) && access_val(bs)
    inhale foo_val(as) == 0

    var a1: Ref
    assume a1 in as
    a1.val := 1 + a1.val - 1

    var b1: Ref
    assume b1 in bs
    b1.val := 1
    exhale access_val(bs)

    exhale foo_val(as) == 0
}

method test_one(as: Set[Ref]) {
    inhale access_one(as)
    inhale foo_one(as) == 0
    exhale foo_one(as) == 0
}

method test_one_2(as: Set[Ref], bs: Set[Ref]) {
    inhale access_one(as) && access_one(bs)
    inhale foo_one(as) == 0

    var a1: Ref
    assume a1 in as
    unfold one(a1)
    a1.val := 1 + a1.val - 1
    fold one(a1)

    var b1: Ref
    assume b1 in bs
    exhale one(b1)
    exhale access_one(bs setminus Set(b1))

    exhale foo_one(as) == 0
}

method test_two(as: Set[Ref], is: Set[Int]) {
    inhale access_two(as, is)
    inhale foo_two(as, is) == 0
    exhale foo_two(as, is) == 0
}

method test_two_2(as: Set[Ref], is: Set[Int], bs: Set[Ref], js: Set[Int]) {
    inhale access_two(as, is) && access_two(bs, js)
    inhale foo_two(as, is) == 0

    var a1: Ref; var i1: Int
    assume a1 in as && i1 in is
    unfold two(a1, i1)
//    a1.val := 1 + a1.val - 1
    fold two(a1, i1)

//    var b1: Ref; var j1: Int
//    assume b1 in bs && j1 in js
//    exhale two(b1, j1)
//    exhale access_two(bs setminus Set(b1), js setminus Set(j1))

    exhale foo_two(as, is) == 0 // CURRENTLY FAILS IN SILICON
}
